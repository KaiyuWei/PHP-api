### Api Setup
- Add your database config in the required variables in `.env.example` and add the environment variables into your `.env` file.
- run `composer install` if necessary.
- run `php -S localhost:8000` to start the server.
- run all the migration scripts in `/database/migrations` for creating tables needed in your database. There are also some seeders available in `/database/seeders` folder for seeding some dummy data for testing.
- Api documentation generated by Swagger are available in http://localhost:8000/public/swagger-ui/ . You can also use this UI to test all available APis. For getting authenticated, there are two APis for regietration and login. You can get a token by registering ad login. However, a user can only be registered as `tranee` for safety reasons. You can manually change the role in you `users` table. 



## Database Schema

All database only includes necessary columns for this test. In practice each table can have more columns.

- `supermarkets` and `wholesalers` has a many-to-many relationship. One supermarket can purchase stock from multiple wholesalers, and wholesaler can sell stock to multiple supermarkets. The many-to-many relationship are maintained by `supermarket_wholesaler` table.
- `outlets` has a one-to-one relationship to `wholesaler`. In reverse, `wholesalers` has a has-many relationship to many `outlets`. These relationships are based on the reality: outlets are owned by wholesalers or factories, for selling some long-time stock with a lower price. A wholesaler can have multiple outlets. This relationship is maintained by a foreign key constraint from `outlets.wholesaler_id` to `wholesalers.id`.
- In this test, I'm able to have the access to all the data in the supply chain. Therefore, I assume that I'm creating a platform for managing data in the whole process, from wholesalers to supermarkets, from wholesalers to outlets. Based on this I choose to manage the stock from `wholesalers`, `supermarkets` and `outlets`. The `stock` table has two columns `owner_type`, `owner_id` which can be used for determine the owner of the stock. There will be more about it, e.g. the comparison of different solutions, how to keep referential integrity, etc., in later part of this readme file. 
- `users` table is currently isolated with other tables. It is only used for user authentication and authorization now. It has two options for its `roles` column: "admin" or "trainee". An admin has all access to all tables while an trainee can usually only read data. In practice, it can have columns referring to other tables, indicating a user's access to different operations on different entities.

![Database Schema.png](https://github.com/Roamler-Code-Tests/fmcg-platform-api-KaiyuWei/blob/pure-PHP-solution/storage/Database%20Schema.png?raw=true)


## Codebase
### Routing
The routing function is mainly achieved by `ApiRouter` and some routing parsers. With them, not only static routings, but also dynamic routings such as `\api\supermarket\{id}` can be used, which enhances the flexibility of the routing system.

### Requests and Data Processing
The app has some most basic classes for serving requests: 
- `Controller` gets the data from the request, do authentication and some data validations, which ensures the validity of the request and the security of the app. Then it transfer the request data to `Service`. Later it gets processing result from `Service` and respond data or status, based on the processing result, to clients.
- `Service` gets data from `Controllers` and implements some business logic, and interacts with databases via `Model`. It also do some validation that needs to interact with DB, e.g. validating that a email for registering a new user is not registered before.
- `Model` interacts with DB directly, executing sql queries. Thanks to `Service`, it does not have to hold some long, unclean, and DB-irrelevant code in its classes.

#### Validator
`Validator` is used for checking the validity of data sent by request. With them, invalid data, dangerous data, not-allowed data... will be rejected with corresponding error messages and status code.

#### Filtering, Sorting and Pagination
`QueryFilter` and `QuerySorter` handle filtering and sorting respectively. As for pagination, it involves some calculation of the query offset, together with `LIMIT` in sql queries. You can find the the interesting logic in methods of `StockService` class. 

### Authentication and Authorization
- When a user logs in, a token is generated, stored in the `token` column of `users` table, and send to the client in response. This token can is used for authentication. Exception for "Register" and "Login" apis, All the other CRUD options need user authentication.
- `role` column in `users` table is for authorization. Currently there are two roles for users: `admin` and `trainee`.
